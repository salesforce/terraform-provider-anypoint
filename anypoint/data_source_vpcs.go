package anypoint

import (
	"context"
	"io/ioutil"
	"strconv"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	vpc "github.com/mulesoft-anypoint/anypoint-client-go/vpc"
)

func dataSourceVPCs() *schema.Resource {
	return &schema.Resource{
		ReadContext: dataSourceVPCsRead,
		Description: `
		Reads the ` + "`" + `vpcs` + "`" + ` available in the business group.
		`,
		Schema: map[string]*schema.Schema{
			"org_id": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "The organization id where the vpc is defined.",
			},
			"vpcs": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: "List of vpcs defined in the given organization",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"id": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "The unique id of this vpc generated by the anypoint platform.",
						},
						"name": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "The name of the vpc.",
						},
						"region": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "The CloudHub region where this VPC will exist",
						},
						"cidr_block": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "The IP address range that the VPC will use. The largest is /16 and the smallest, /24",
						},
						"internal_dns_servers": {
							Type:     schema.TypeList,
							Optional: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Description: "List of internal dns servers",
						},
						"internal_dns_special_domains": {
							Type:     schema.TypeList,
							Optional: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Description: "List of internal dns special domains",
						},
						"is_default": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If set to true, the VPC will be associated to all CloudHub environments not explicitly associated to another VPC, including newly created ones",
						},
						"associated_environments": {
							Type:     schema.TypeList,
							Optional: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Description: "A list of CloudHub environments to associate to this VPC",
						},
						"owner_id": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "The id of the organization that owns the VPC",
						},
						"shared_with": {
							Type:     schema.TypeList,
							Optional: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Description: "A list of Business Groups to share this VPC with",
						},
						"firewall_rules": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: "Inbound firewall rules for all CloudHub workers in this VPC. The list is allow only with an implicit deny all if no rules match",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"cidr_block": {
										Type:     schema.TypeString,
										Required: true,
									},
									"protocol": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"from_port": {
										Type:     schema.TypeInt,
										Optional: true,
									},
									"to_port": {
										Type:     schema.TypeInt,
										Optional: true,
									},
								},
							},
						},
						"vpc_routes": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: "The network routes of this vpc.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"next_hop": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"cidr": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func dataSourceVPCsRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	// Warning or errors can be collected in a slice type
	var diags diag.Diagnostics
	pco := m.(ProviderConfOutput)
	orgid := d.Get("org_id").(string)
	authctx := getVPCAuthCtx(ctx, &pco)

	//request vpcs
	res, httpr, err := pco.vpcclient.DefaultApi.OrganizationsOrgIdVpcsGet(authctx, orgid).Execute()

	if err != nil {
		var details string
		if httpr != nil {
			b, _ := ioutil.ReadAll(httpr.Body)
			details = string(b)
		} else {
			details = err.Error()
		}
		diags = append(diags, diag.Diagnostic{
			Severity: diag.Error,
			Summary:  "Unable to Get VPCs",
			Detail:   details,
		})
		return diags
	}
	defer httpr.Body.Close()

	//process data
	data := res.GetData()
	vpcs := flattenVPCsData(&data)
	//save in data source schema
	if err := d.Set("vpcs", vpcs); err != nil {
		diags = append(diags, diag.Diagnostic{
			Severity: diag.Error,
			Summary:  "Unable to set VPCs",
			Detail:   "Unable to set VPCs in resource schema",
		})
		return diags
	}

	// always run
	d.SetId(strconv.FormatInt(time.Now().Unix(), 10))

	return diags
}

func flattenVPCsData(vpcs *[]vpc.Vpc) []interface{} {
	if vpcs != nil && len(*vpcs) > 0 {
		res := make([]interface{}, len(*vpcs))

		for i, vpcitem := range *vpcs {
			item := make(map[string]interface{})

			item["id"] = vpcitem.GetId()
			item["name"] = vpcitem.GetName()
			item["region"] = vpcitem.GetRegion()
			item["cidr_block"] = vpcitem.GetCidrBlock()
			item["internal_dns_servers"] = vpcitem.GetInternalDns().DnsServers
			item["internal_dns_special_domains"] = vpcitem.GetInternalDns().SpecialDomains
			item["is_default"] = vpcitem.GetIsDefault()
			item["associated_environments"] = vpcitem.GetAssociatedEnvironments()
			item["owner_id"] = vpcitem.GetOwnerId()
			item["shared_with"] = vpcitem.GetSharedWith()

			frules := make([]interface{}, len(vpcitem.GetFirewallRules()))
			for j, frule := range vpcitem.GetFirewallRules() {
				r := make(map[string]interface{})
				r["cidr_block"] = frule.GetCidrBlock()
				r["protocol"] = frule.GetProtocol()
				r["from_port"] = frule.GetFromPort()
				r["to_port"] = frule.GetToPort()
				frules[j] = r
			}
			item["firewall_rules"] = frules

			vpcroutes := make([]interface{}, len(vpcitem.GetVpcRoutes()))
			for j, vpcroute := range vpcitem.GetVpcRoutes() {
				r := make(map[string]interface{})
				r["next_hop"] = vpcroute.GetNextHop()
				r["cidr"] = vpcroute.GetCIDR()
				vpcroutes[j] = r
			}
			item["vpc_routes"] = vpcroutes

			res[i] = item
		}
		return res
	}

	return make([]interface{}, 0)
}
